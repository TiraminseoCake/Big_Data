# 빅데이터 분석 프로젝트: 락(lock) 메커니즘 비교 실험 보고서

## 1. 실험 목적
본 실험의 목적은 **멀티스레딩 환경에서 락(lock) 타입별 병렬 처리 성능 차이**를 분석하는 것이다.  
A3C 알고리즘의 병렬화 개념을 응용하여 각 락 타입이 공유 자원 접근 시 어떤 성능적 차이를 보이는지 비교하였다.

---

## 2. 실험 환경
- **언어**: C++ (std::thread 기반)
- **실행 환경**: Windows 10, Visual Studio 2022
- **CPU**: Intel i7-12700H (12 Cores, 20 Threads)
- **스레드 수**: 8
- **공유 변수 접근 횟수**: 1,000,000회

---

## 3. 락(lock) 타입별 실험
락 타입은 다음 네 가지로 구분하여 실험을 진행하였다.

1. **nolock (락 없음)**  
   - 동기화 없이 공유 자원에 접근.  
   - 경쟁 상태(race condition)가 발생할 수 있음.  

2. **tas (Test-And-Set, 기본 스핀락)**  
   - 한 번의 원자적 테스트 후 락을 획득할 때까지 반복 대기.  
   - CPU를 계속 점유하므로 대기 시간이 길어질 수 있음.  

3. **ttas (Test-Test-And-Set, 개선된 스핀락)**  
   - 먼저 락 상태를 읽고 필요할 때만 Test-And-Set 수행.  
   - TAS에 비해 불필요한 원자 연산 횟수를 줄여 효율성을 개선.  

4. **backoff (백오프 스핀락)**  
   - 락 획득 실패 시 짧은 시간 대기 후 재시도.  
   - 바쁜 대기 동안 CPU 점유를 줄이고 락 경쟁이 심한 상황에서 성능 향상.

---

## 4. 실험 결과

### (1) nolock 사용 시
![nolock 결과]


- 실행 시간: 약 **1300ms**
- 특징: 동기화가 없어 가장 빠름. 단, race condition 가능성 존재.

---

### (2) tas 사용 시
![tas 결과](1.PNG)

- 실행 시간: 약 **2100ms**
- 특징: 기본 스핀락으로 안정적이지만 CPU 점유율이 높음.

---

### (3) ttas 사용 시
![ttas 결과](2.PNG)

- 실행 시간: 약 **1800ms**
- 특징: TAS보다 효율적이며, 불필요한 원자 연산 감소.

---

### (4) backoff 사용 시
![backoff 결과](3.PNG)

- 실행 시간: 약 **1500ms**
- 특징: 백오프 전략으로 CPU 점유를 줄여 락 경쟁이 심할 때 성능 향상.

---

## 5. 결과 비교 요약

| 락 타입 | 실행 시간(ms) | 특징 |
|----------|----------------|------|
| nolock | 1300 | 가장 빠름, 동기화 없음 |
| tas | 2100 | 기본 스핀락, CPU 점유율 높음 |
| ttas | 1800 | 개선된 스핀락, 원자 연산 감소 |
| backoff | 1500 | 백오프 스핀락, 경쟁 상황에서 효율적 |

---

## 6. 결론
본 실험을 통해 **락의 선택이 병렬 프로그램의 성능에 큰 영향을 미친다는 점**을 확인할 수 있었다.  
- 단순한 연산이나 race condition 위험이 적다면 `nolock` 사용이 가장 효율적이며,  
- 경쟁이 심한 환경에서는 `backoff`나 `ttas`가 성능과 안정성의 균형을 제공한다.  


---

## 7. 참고 사항
- 실험은 동일한 조건에서 5회 반복 측정 후 평균값을 기록하였다.
- 이미지 내 실행 결과는 콘솔 출력 캡처이며, 스레드별 처리 시간이 포함되어 있다.
