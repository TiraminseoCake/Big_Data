# 빅데이터 분석 프로젝트: 락(lock) 메커니즘 비교 실험 보고서

## 1. 실험 목적
본 실험의 목적은 **멀티스레딩 환경에서 락(lock) 타입별 병렬 처리 성능 차이**를 분석하는 것이다.  
특히 공유 자원 접근 시 발생할 수 있는 경쟁 상태(race condition)와 CPU 점유율을 고려하여 각 락 메커니즘의 효율성과 안정성을 비교하였다.

---

## 2. 실험 환경
- **언어**: C++ (std::thread 기반)
- **실행 환경**: Windows 10, Visual Studio 2022
- **CPU**: Intel i7-12700H (12 Cores, 20 Threads)
- **스레드 수**: 2, 4, 8, 16, 32 (실험별 성능 비교)
- **공유 변수 접근 횟수**: 1,000,000회

---

## 3. 락(lock) 타입별 실험
본 실험에서는 다음 네 가지 락 메커니즘을 비교하였다.

1. **nolock (락 없음)**  
   - 동기화 없이 공유 자원에 접근.  
   - 가장 빠르지만, race condition이 발생할 수 있음.  

2. **tas (Test-And-Set, 기본 스핀락)**  
   - 한 번의 원자적 테스트 후 락을 획득할 때까지 반복 대기.  
   - CPU를 계속 점유하므로 대기 시간이 길어질 수 있음.  

3. **ttas (Test-Test-And-Set, 개선된 스핀락)**  
   - 먼저 락 상태를 읽고 필요할 때만 Test-And-Set 수행.  
   - TAS보다 불필요한 원자 연산을 줄여 효율성을 개선.  

4. **backoff (백오프 스핀락)**  
   - 락 획득 실패 시 짧은 시간 대기 후 재시도.  
   - 바쁜 대기 동안 CPU 점유를 줄여, 락 경쟁이 심한 환경에서 성능 향상.

---

## 4. 실험 결과

### (1) nolock 사용 시
![nolock 결과](0.PNG)

- 실행 시간: 약 **1300ms**
- 특징: 동기화가 없어 가장 빠르지만, race condition 가능성 존재.

---

### (2) tas 사용 시
![tas 결과](1.PNG)

- 실행 시간: 약 **2100ms**
- 특징: 안정적이지만 CPU 점유율이 높음.

---

### (3) ttas 사용 시
![ttas 결과](2.PNG)

- 실행 시간: 약 **1800ms**
- 특징: TAS보다 효율적이며, 불필요한 원자 연산이 감소.

---

### (4) backoff 사용 시
![backoff 결과](3.PNG)

- 실행 시간: 약 **1500ms**
- 특징: 백오프 전략으로 락 경쟁이 심할 때 성능 향상.

---

## 5. 결과 비교 요약

| 락 타입 | 실행 시간(ms) | 특징 |
|----------|----------------|------|
| nolock | 1300 | 동기화 없음, 가장 빠름, race condition 가능 |
| tas | 2100 | 기본 스핀락, CPU 점유율 높음 |
| ttas | 1800 | 개선된 스핀락, 원자 연산 감소 |
| backoff | 1500 | 백오프 스핀락, 경쟁 환경에서 효율적 |

---

## 6. 결론
본 실험을 통해 **락 선택이 멀티스레딩 프로그램의 성능과 안정성에 큰 영향을 미친다는 점**을 확인할 수 있었다.  
- **단순한 연산이나 경쟁 상태 위험이 적은 환경**에서는 `nolock`이 가장 빠르다.  
- **경쟁이 심한 환경**에서는 `ttas`나 `backoff`가 성능과 안정성의 균형을 제공한다.  
- TAS는 구조가 단순하지만 CPU 점유율이 높아, 성능 최적화에는 다소 불리하다.

이번 실험은 멀티스레딩 환경에서 락 메커니즘을 선택할 때 **성능과 안정성의 trade-off**를 고려해야 함을 보여준다.

---

## 7. 참고 사항
- 동일 조건에서 5회 반복 측정 후 평균값을 기록하였다.  
- 이미지 내 실행 결과는 콘솔 출력 캡처이며, 스레드별 처리 시간이 포함되어 있다.
